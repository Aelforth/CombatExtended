using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using RimWorld;
using Verse;
using UnityEngine;

namespace CombatExtended
{
    public class ChargeAdder
    {
        public ThingDefCountClass ammo;
        public bool isFallback = false;

        //Normally:
        //<Ammo>chargesAdded</Ammo>
        //Add fallback for <Ammo Added="chargesAdded"/>
    }

    public class ChargeUser
    {
        //Same format as explosive comp fragments -- ALTHOUGH THINGDEFCOUNT IS ENOUGH?
        public List<ThingDefCountClass> projectiles;
        public int chargesUsed;

        //Normally:
        //<chargesUsed>chargesUsed</chargesUsed>
        //<projectiles>
        //  <Projectile>amountFired</Projectile>
        //</projectiles>
        //Add fallback for <Projectile Used="chargesUsed">amountFired</Projectile>?
        //Add fallback for <Projectile Used="chargesUsed" Fired="amountFired"/>?
    }

    public class AmmoLink
    {
        /*Normally:
        <ammoTypes>
            <li>
                <adders>
                    <li>
                        <Ammo>X</Ammo>
                        <isFallback>True</isFallback>
                    </li>
                    <li>
                        <Ammo>X</Ammo>
                    </li>
                </adders>
                <users>
                    <li>
                        <chargesUsed>Y</chargesUsed>
                        <projectiles>
                            <Projectile>A</Projectile>
                            <Projectile>A</Projectile>
                        </projectiles>
                    </li>
                    <li>
                        <chargesUsed>1</chargesUsed>
                        <projectiles>
                            <Projectile>A</Projectile>
                        </projectiles>
                </users>
                <spentThingDef>SpentAmmo</spentThingDef>
                <fallbackThingDef>Fallback</fallbackThingDef>
                <autogenerateFallbackUser>True</autogenerateFallbackUser>
                <chanceToRecoverBacklog>True</chanceToRecoverBacklog>
            </li>
        </ammoTypes>
        */
        //Fallback for <Ammo Added="chargesAdded" Used="chargesUsed">Projectile</Ammo>?

        /*(non-int X/Y CASE)
        //If nothing:
        //- Fire shot as long as at least one charge remains
        //With fallback user with appropriate X / Y integer:
        //- Fallback shot is fired
        //With boolean (bool autogenerateFallbackUser == true):
        //- Fallback is autogenerated with lower pelletCount and other stats
        */

        /*(non-int Y/X CASE)
        //If nothing:
        //- Unload backlog charges by destroying them
        //With spent ammo (ChargeAdder.spentThingDef)
        //- Unload spent ammo, any backlog is turned to spent ammo
        //With chance to return (bool chanceToRecoverBacklog == true)
        //- Recover full cartridge based on discrepancy
        //With fallback (ChargeAdder.fallbackThingDef)
        //- Unload fallback thing for every backlog charge
        */

        /*(Magazine size issues)
        //With variable 
        //- Calculate magazine size from X, Y (both lead and set limits somehow)
        */

        #region Fields
        //Index of lists is the amount of charges added or used?
        public List<ChargeAdder> adders;
        public List<ChargeUser> users;

        public bool allowMagsizeChange = true;
        public bool autogenerateFallbackUser = true;
        public bool chanceToRecoverBacklog = true;

        public ThingDef spentThingDef;
        public ThingDef fallbackThingDef;

        public string label;
        #endregion

        public AmmoDef ammo;
        public ThingDef projectile;

        #region Methods
        public bool SuggestMagSize(int currentMagSize, out int newMagSize)
        {
            if (!allowMagsizeChange)
            {
                newMagSize = currentMagSize;
                return false;
            }

            //Find all X, Y

            //TODO: Calculate new size based on X, Y

            newMagSize = currentMagSize;
            return true;
        }

        public AmmoLink() { }

        public AmmoLink(AmmoDef ammo, ThingDef projectile)
        {
            this.ammo = ammo;
            this.projectile = projectile;
        }

        public void LoadDataFromXmlCustom(XmlNode xmlRoot)
        {
            if (xmlRoot.ChildNodes.Count != 1)
            {
                Log.Error("Misconfigured AmmoLink: " + xmlRoot.OuterXml);
                return;
            }
            DirectXmlCrossRefLoader.RegisterObjectWantsCrossRef(this, "ammo", xmlRoot.Name);
            DirectXmlCrossRefLoader.RegisterObjectWantsCrossRef(this, "projectile", (string)ParseHelper.FromString(xmlRoot.FirstChild.Value, typeof(string)));
            if (xmlRoot.Attributes["Amount"] != null)
                amount = (int)ParseHelper.FromString(xmlRoot.Attributes["Amount"].Value, typeof(int));
        }
        #endregion

        /* From:
        <ammoTypes>
            <Shell_HighExplosive>Bullet_81mmMortarShell_HE</Shell_HighExplosive>
        </ammoTypes>
        */

        /* To:
        <ammoTypes>
            <li>
                <adders>
                    <li>
                        <Shell_HighExplosive>1</Shell_HighExplosive>
                        <isFallback>True</isFallback>
                    </li>
                </adders>
                <users>
                    <li>
                        <chargesUsed>1</chargesUsed>
                        <projectiles>
                            <li>
                                <Bullet_81mmMortarShell_HE>1</Bullet_81mmMortarShell_HE>
                            </li>
                        </projectiles>
                    </li>
                </users>
            </li>
        </ammoTypes>
        */

        public override string ToString()
        {
            return "("
                + (ammo == null ? "null" : ammo.defName)
                + (amount > 1 ? "x" + amount + " -> " : " -> ")
                + (projectile == null ? "null" : projectile.defName + ")");
        }

        public override int GetHashCode()
        {
            return ammo.shortHash + projectile.shortHash + amount << 16;
        }
    }
}
