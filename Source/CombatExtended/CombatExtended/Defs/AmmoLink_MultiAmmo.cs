using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using RimWorld;
using Verse;
using UnityEngine;

namespace CombatExtended
{
    public class AmmoLink_MultiAmmo : AmmoLink
    {
        /*Normally:
        <ammoTypes>
            <li>
                <adders>
                    <li>
                        <Ammo>X</Ammo>
                        <isFallback>True</isFallback>
                    </li>
                    <li>
                        <Ammo>X</Ammo>
                    </li>
                </adders>
                <users>
                    <li>
                        <chargesUsed>Y</chargesUsed>
                        <projectiles>
                            <Projectile>A</Projectile>
                            <Projectile>A</Projectile>
                        </projectiles>
                    </li>
                    <li>
                        <chargesUsed>1</chargesUsed>
                        <projectiles>
                            <Projectile>A</Projectile>
                        </projectiles>
                </users>
                <spentThingDef>SpentAmmo</spentThingDef>
                <fallbackThingDef>Fallback</fallbackThingDef>
                <autogenerateFallbackUser>True</autogenerateFallbackUser>
                <chanceToRecoverBacklog>True</chanceToRecoverBacklog>
            </li>
        </ammoTypes>
        */
        //Fallback for <Ammo Added="chargesAdded" Used="chargesUsed">Projectile</Ammo>?

        /*(non-int X/Y CASE)
        //If nothing:
        //- Fire shot as long as at least one charge remains
        //With fallback user with appropriate X / Y integer:
        //- Fallback shot is fired
        //With boolean (bool autogenerateFallbackUser == true):
        //- Fallback is autogenerated with lower pelletCount and other stats
        */

        /*(non-int Y/X CASE)
        //If nothing:
        //- Unload backlog charges by destroying them
        //With spent ammo (ChargeAdder.spentThingDef)
        //- Unload spent ammo, any backlog is turned to spent ammo
        //With chance to return (bool chanceToRecoverBacklog == true)
        //- Recover full cartridge based on discrepancy
        //With fallback (ChargeAdder.fallbackThingDef)
        //- Unload fallback thing for every backlog charge
        */

        /*(Magazine size issues)
        //With variable 
        //- Calculate magazine size from X, Y (both lead and set limits somehow)
        */

        #region Fields
        public bool allowMagsizeChange = true;
        public bool autogenerateFallbackUser = true;

        /// <summary>Whether the index of the charge adder and that of the charge user it creates are the same - useful for e.g catapults</summary>
        public bool directAdderUserLinkage = false;
        #endregion

        #region Methods
        public bool SuggestMagSize(int currentMagSize, out int newMagSize)
        {
            if (!allowMagsizeChange)
            {
                newMagSize = currentMagSize;
                return false;
            }

            //Find all X, Y

            //TODO: Calculate new size based on X, Y

            newMagSize = currentMagSize;
            return true;
        }

        /*
        public AmmoLink() { }

        public AmmoLink(AmmoDef ammo, ThingDef projectile)
        {
            this.ammo = ammo;
            this.projectile = projectile;
        }*/

        public override bool CanAdd(ThingDef def)
        {
            return adders.Any(x => x.thingDef == def);
        }

        /// <summary>Returns </summary>
        /// <param name="def"></param>
        /// <param name="adder">ThingDef and amount of charges added by that def</param>
        /// <returns></returns>
        public override bool CanAdd(ThingDef def, out int chargesPerUnit)
        {
            chargesPerUnit = adders.First(x => x.thingDef == def)?.count ?? -1;
            return chargesPerUnit != -1;
        }
        
        /*
        public virtual IEnumerable<Thing> BestFullMagazine(List<Thing> things, CompAmmoUser user)
        {
            foreach (var adder in things
                .Select(x => { CanAdd(x, user, out var adder); return adder; })
                .OrderByDescending(y => y.ammo.count))
            {

            }
        }*/

        /// <summary>
        /// 
        /// </summary>
        /// <param name="things">A collection of Things, e.g from the inventory</param>
        /// <param name="user"></param>
        /// <param name="defCount">The amount of charges associated with the returned Thing</param>
        /// <returns></returns>
        public override Thing BestAdder(IEnumerable<Thing> things, CompAmmoUser user, out int chargeCount, bool maxStackSize = false, bool canFit = true)
        {
            // From the largest to the smallest possible adder ..
            foreach (var dc in allowOverflow
                ? adders.OrderByDescending(x => x.count)
                : adders.Where(x => user.CurMagCount + x.count <= user.Props.magazineSize).OrderByDescending(x => x.count))
            {
                // .. test if it's in things and take the smallest (or largest with maxStackSize = true) stack of it
                var test = things.Where(x => x.def == dc.thingDef).MaxByWithFallback(x => (maxStackSize ? 1 : -1) * x.stackCount);
                if (test != null)
                {
                    chargeCount = dc.count;
                    return test;
                }
            }

            chargeCount = 0;
            return null;
        }
        
        public override ChargeUser BestUser(CompAmmoUser user)
        {
            // If no charge is remaining, do not return any best user
            if (user.CurChargeCount <= 0)
                return null;
            
            // If adders and users are strongly linked, only one return value is possible
            if (directAdderUserLinkage && CanAdd(user.CurrentAdder.def))
            {
                var linkedUser = users[adders.FindIndex(x => x.thingDef == user.CurrentAdder.def)
                    % users.Count];     //% users.Count handles incorrectly prepared XML (users.Count != adders.Count)
                
                return (allowUnderflow || user.CurChargeCount >= linkedUser.chargesUsed)
                    ? linkedUser : null;
            }
            
            //1. Fire a shot as long as there's at least one charge remaining
            var availableUsers = users.Where(x => x.chargesUsed <= user.CurChargeCount);
            if (availableUsers != null)
                return availableUsers.MaxByWithFallback(y => y.chargesUsed);

            //3. Somehow linearly decreasing projectile stats with lower ammo amounts, e.g cutting pelletCount or damage or AP, or speed.
            //2. Having an option with the current X and different Y which does have X / Y integer as fallback, handling a tiered decrease in projectile properties.

            //4. Allow for an underflow of rounds, which has to be replenished with newly loaded ammo
            return allowUnderflow
                ? (users.Where(x => x.chargesUsed > user.CurChargeCount)?.MinBy(y => y.chargesUsed) ?? null)
                : null;
        }
        #endregion

        public override IEnumerable<string> ConfigErrors()
        {
            foreach (var err in base.ConfigErrors())
                yield return err;

            if (directAdderUserLinkage && adders.Count != users.Count)
                yield return "has directAdderUserLinkage (requires adders.Count == users.Count), but adder and user list sizes aren't equal";
        }

        /* From:
        <ammoTypes>
            <Shell_HighExplosive>Bullet_81mmMortarShell_HE</Shell_HighExplosive>
        </ammoTypes>
        */

        /* To:
        <ammoTypes>
            <li>
                <adders>
                    <li>
                        <Shell_HighExplosive>1</Shell_HighExplosive>
                        <isFallback>True</isFallback>
                    </li>
                </adders>
                <users>
                    <li>
                        <chargesUsed>1</chargesUsed>
                        <projectiles>
                            <li>
                                <Bullet_81mmMortarShell_HE>1</Bullet_81mmMortarShell_HE>
                            </li>
                        </projectiles>
                    </li>
                </users>
            </li>
        </ammoTypes>
        */

        /*
        public override string ToString()
        {
            return "("
                + (ammo == null ? "null" : ammo.defName)
              //+ (amount > 1 ? "x" + amount + " -> " : " -> ")
                + (projectile == null ? "null" : projectile.defName + ")");
        }

        public override int GetHashCode()
        {
            return ammo.shortHash + projectile.shortHash + amount << 16;
        }*/
    }
}
